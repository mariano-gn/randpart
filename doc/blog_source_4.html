<a href="#es">Espa√±ol</a>
<a id="top"></a>
<br>
Hello!

Continuing with the articles from the Particles demo. This time not that much related with Particles though, I'll present you the camera implementation I made. A very simple version of a orbit-dolly-pan camera using the <a href="http://glm.g-truc.net/">GLM Math library</a>.
 <h1>Camera operations</h1>
 First things first, a definitions for the 3 operations.
 <h4>Orbit</h4>
 Orbiting the camera works as in "orbit around the planet". The camera has a pivot point and moves over the surface of the sphere with center on that pivot and radius equal to the distance between the camera position and the point.

 The operation doesn't change neither the pivot nor the distance between pivot and camera.
 <h4>Pan</h4>
 Pan operations allow the camera to move in the plane given by the position of the camera and the forward vector, just like panning an image on any visualization app.

 In my case, this operation does change the pivot point position but not the distance between it and the camera.
 <h4>Dolly</h4>
 This operation is usually confused with zoom or named zoom incorrectly, the operation moves the camera within its forward vector. The confusion comes from the fact that zoom adjust the <a href="https://en.wikipedia.org/wiki/Field_of_view">field of view</a>, so both operation increase/decrease the elements size on screen but they're different in terms of implementation and final results.

 Also, they work on different matrices, while dolly adjust the view matrix (when changing the camera position), zooming will change the perspective and, in consequence, the projection matrix.
<h1>Particles Camera</h1>
<h2>Public interface</h2>
[code language="cpp"]
class camera {
public:
    camera(const glm::vec2& screen);
    void screen_change(const glm::vec2& screen);
    void home();

    void dolly(float dz);
    void pan(const glm::vec2& dd);
    void orbit(const glm::vec2& dd);

    const glm::mat4x4& get_vp() const;

    ~camera() = default;
[/code]
The only parameter is the screen resolution (<code>glm::vec2{width, height}</code>), I didn't make it very customizable...

Then we have <code>screen_change(...)</code>, which is a function to call when the size of the viewable area (viewport) changed, and <code>home()</code> used to set the default parameters for the camera.

After that we have the operations <code>orbit(...)</code>, <code>pan(...)</code> and <code>dolly(...)</code>.
<code>orbit(...)</code> and <code>pan(...)</code> receive a 2-dimensional displacement (i.e. screen coordinates) and <code>dolly(...)</code> a relative displacement over the forward vector (I use a right hand system with Y pointing up, hence <i>dz</i>).

Finally we have a default destructor and the function to retrieve the view-projection matrix suitable to use on the final shader.
<h2>Private members</h2>
[code language="cpp"]
private:
    glm::vec3 m_pos, m_lookAt, m_up;
    float m_pan_vel = .1f;
    float m_dolly_vel = 3.f;
    float m_orbit_vel = 4.f;

    glm::mat4x4 m_projection;
    mutable glm::mat4x4 m_vp;
    mutable bool m_dirty = true;
[/code]
The first three members are used to keep track of where the camera is, where is looking at (point in space, the pivot for orbit, not just a direction) and where is the <i>up</i> direction.

Later we have 3 velocity modifiers for each operation that I tuned for the particles. They could be exposed and modified but I didn't find that necesary for the demo. They affect how fast (or slow) the camera moves on each operation.

After that we have the projection matrix (that only changes by screen changes) and 2 mutable members. They're mutable because they're used on a const method but they're intended as a cache for an optimization, the valuable members are those used for position, lookAt and up.

I did this that way because on each operation is easier to modify this members, but calculating the view-projection matrix each frame, even if the camera didn't moved looked like a waste. As any cache, the dirty flag is used to update it.
<h2>Implementation</h2>
[code language="cpp"]
camera::camera(const glm::vec2& screen) {
    screen_change(screen);
    home();
}

void camera::screen_change(const glm::vec2& screen) {
    m_projection = glm::perspective(glm::radians(45.f), screen.x / screen.y, .5f, 100.f);

    m_dirty = true;
}

void camera::home() {
    m_pos = glm::vec3{ 0.f, 0.f, 2.7f };
    m_lookAt = glm::vec3{ 0.f, 0.f, 0.f };
    m_up = glm::vec3{ 0.f, 1.f, 0.f };
    m_dirty = true;
}
[/code]
First three methods, nothing really important. The constructor just delegates the work on the other 2. <code>screen_change</code> recalculates the projection matrix as a perspective projection with Pi/4 radians for the vertical field of view and .5 and 100 as near and far planes (lots of space to dollying in the particle demo that is around (0, 0, 0)). I'm relying on the GLM implementation of the perspective matrix construction :)

Note: I'm using <code>glm::radians</code> because I force GLM to work on radians. And I work on radians because... I don't know, I got used to it.

As you can see, plenty more parameters to expose :)
<h3>Dolly</h3>
[code language="cpp"]
void camera::dolly(const float dz) {
    // TODO: Dolly based on hit point (not center, using mouse screenpos)
    const auto move = m_pos - m_lookAt;
    const auto curr_dist = glm::length(move);
    const auto new_dist = glm::clamp(dz * m_dolly_vel + curr_dist, 1.f, 50.f);

    m_pos = m_lookAt + (glm::normalize(move) * new_dist);
    m_dirty = true;
}
[/code]
The dolly operation first calculates the current inverse forward vector and its length

Then calculates the new distance by adding the displacement scaled by the velocity parameter (the clamp operation ensures at least one unit and no more than 50).

Finally obtains the new position of the camera with the inverse forward vector and the new distance. As I said, since this operation changes camera properties, the dirty flag is activated.
<h3>Pan</h3>
[code language="cpp"]
void camera::pan(const glm::vec2& dd) {
    // TODO: Pan with hit point always below mouse (using mouse screenpos)
    auto adjusted_dd = dd * m_pan_vel;

    auto rev_foward = glm::normalize(m_pos - m_lookAt);
    auto right_move = glm::normalize(glm::cross(m_up, rev_foward)) * -adjusted_dd.x;
    auto up_move = m_up * adjusted_dd.y;
    auto move = up_move + right_move;
    m_pos += move;
    m_lookAt += move;
    m_dirty = true;
}
[/code]
Pan modifies both the pivot point and the camera position. Doing a similar operation than dolly it calculates the new position moving the camera left or right and top or bottom depending on the x and y displacements respectively.

It then applies the same displacement to the lookAt point (pivot) so to maintain the same forward vector and its length.
<h3>Orbit</h3>
[code language="cpp"]
void camera::orbit(const glm::vec2& dd) {
    // TODO: Orbit with hit point always below mouse (using mouse screenpos)
    auto adjusted_dd = dd * m_orbit_vel;
    auto rev_foward = m_pos - m_lookAt;
    const auto len_rf = glm::length(rev_foward);
    rev_foward = glm::normalize(rev_foward);

    const auto h_rot = glm::rotate(glm::radians(-adjusted_dd.x), m_up);
    const auto v_rot = glm::rotate(glm::radians(-adjusted_dd.y), glm::normalize(glm::cross(m_up, rev_foward)));
    m_pos = m_lookAt + glm::vec3{ h_rot * v_rot * glm::vec4{ rev_foward, 0.f } } * len_rf;
    m_up = glm::vec3{ v_rot * glm::vec4{ m_up, 0.f } };
    m_dirty = true;
}
[/code]
Orbit is a bit more complex, but not that much. Think of 2 rings around the pivot point, one horizontal and one vertical, what it does is calculate 2 rotation matrices over this 2 rings using the displacement parameter and the velocity factor.
Then rotates the inverse forward vector and calculates the new position adding it to the pivot point. The up vector then is only affected by the vertical rotation.
<h3>Obtaining the vp matrix</h3>
[code language="cpp"]
const glm::mat4x4& camera::get_vp() const {
    if (m_dirty) {
        m_vp = m_projection * glm::lookAt(m_pos, m_lookAt, m_up);
        m_dirty = false;
    }
    return m_vp;
}
[/code]
As you can see the view projection matrix is calculated only if the dirty flag is set, otherwise is simply returned. Once again, I'm simplifying by work by using the <code>glm::lookAt</code> function that generates the view matrix using position, lookAt and up vectors.
<h3>TODO, position on screen</h3>
If you noticed, all the methods start with a TODO note. The thing is all of them work on a simplistic way that was good enough for me, and in some cases is the correct and easiest way. But, a possible modification for each involves maintaining some constraint related to the screen position in which the movement was triggered.

In the case of dolly, this implementation keeps whatever pixel was in the center of the screen, always below the center of the screen but, if we think of the screen hit point as the origin of a ray that will intersect with someting in the 3D world (ray picking), the alternative would be to give relevance to the position in which the dolly is performed tilting the displacement of the camera towards the point of intersection of the ray and the world.

This wouldn't change the foward vector, but the displacement vector would be calculated with the intersection point and the camera position, instead of the pivot point.

For pan and orbit, our constraint could be that the intersection point in the 3D world of the screen hit point should always be the same during the entire operation. (Whatever is below the mouse or finger, stays below the mouse or finger)

This 3 things are a little more complex to achieve and it wasn't very important for showing some particles floating with no other reference to me, so they're "left as an exercise for the reader".

This article belongs to the <i>Particles!</i> series, you can see previous entries <a href="https://marianogonzalezn.wordpress.com/2016/04/26/particles-1/">here</a>, <a href="https://marianogonzalezn.wordpress.com/2016/05/09/particles-2/">here</a> and <a href="https://marianogonzalezn.wordpress.com/2016/05/16/particles-3-multithreading/">here</a>. <a href="https://github.com/mariano-gn/randpart">Here</a> is the repo for the particles demo. Hope you like it!
<br>
<a href="#top">Back to Top</a>
<hr>
<a id="es"></a>
<br>
¬°Hola!

Continuando con los art√≠culos de la demo de part√≠culas. Esta vez no muy relacionado con part√≠culas, les presento la implementaci√≥n de la c√°mara que hice. Una versi√≥n muy simple de una c√°mara orbit-dolly-pan usando la <a href="http://glm.g-truc.net/">librer√≠a de matem√°tica GLM</a>.
 <h1>Operaciones de la c√°mara</h1>
 Antes que nada, una definici√≥n de las 3 operaciones.
 <h4>Orbit</h4>
 Orbit (de orbitar) como en "orbita alrededor del planeta". La camara tiene un punto de pivote y se mueve sobre la superficie de la esfera con centro en el pivote y radio igual a la distancia entre √©l y la posici√≥n de la c√°mara.

 Esta operaci√≥n no cambia ni el pivote, ni la distancia entre √©l y la c√°mara.
 <h4>Pan</h4>
 La operaci√≥n de pan ('panear') permite a la c√°mara moverse en el plano dado por la posici√≥n de la c√°mara y el vector <i>forward</i> (hacia donde la c√°mara mira), del mismo modo que se mueve una imagen en una aplicaci√≥n de visualizaci√≥n.

 En mi caso, esta operaci√≥n s√≠ cambia el punto de pivote pero no modifica la distancia entre √©l y la c√°mara.
 <h4>Dolly</h4>
 Esta operaci√≥n usualmente se confunde con zoom o se la nombra incorrectamente, la operaci√≥n mueve la c√°mara a lo largo del vector <i>forward</i>. La confusi√≥n viene del hecho de que el zoom ajusta el √°ngulo de c√°mpo visual (<a href="https://en.wikipedia.org/wiki/Field_of_view">field of view</a>), por lo que ambas agrandan o achican el tama√±o de los elementos en la pantalla pero son diferentes en t√©rminos de implementaci√≥n y resultados.

 Adem√°s, trabajan en diferentes matrices, mientras que dolly ajusta la matriz de vista (al cambiar la posici√≥n de la c√°mara), el zoom cambia la perspectiva y, por ende, la matriz de proyecci√≥n.
<h1>La c√°mara para las part√≠culas</h1>
<h2>Interfaz p√∫blica</h2>
[code language="cpp"]
class camera {
public:
    camera(const glm::vec2& screen);
    void screen_change(const glm::vec2& screen);
    void home();

    void dolly(float dz);
    void pan(const glm::vec2& dd);
    void orbit(const glm::vec2& dd);

    const glm::mat4x4& get_vp() const;

    ~camera() = default;
[/code]
El √∫nico par√°metro es la resoluci√≥n de pantalla (<code>glm::vec2{ancho, alto}</code>), no hice la c√°mara muy parametrizable...

Luego est√°n <code>screen_change(...)</code>, que es una funci√≥n para llamar cuando cambia el tama√±o del √°rea visible (viewport), y <code>home()</code> usada para setear todos los valores por defecto del resto de los par√°metros de la c√°mara.

Al final las operaciones <code>orbit(...)</code>, <code>pan(...)</code> y <code>dolly(...)</code>.
<code>orbit(...)</code> y <code>pan(...)</code> reciben un desplazamiento bidimensional (p.e. coordenadas de pantalla) y <code>dolly(...)</code>  un desplazamiento relativo sobre el vector <i>forward</i> (uso un sistema de mano derecha con la Y apuntando hacia arriba, por eso <i>dz</i>).

Finalmente tenemos el destructor por defecto y la funci√≥n para obtener la matriz vista-proyecci√≥n (<i>view-projection</i>) adecuada para usar en el shader final.
<h2>Miembros privados</h2>
[code language="cpp"]
private:
    glm::vec3 m_pos, m_lookAt, m_up;
    float m_pan_vel = .1f;
    float m_dolly_vel = 3.f;
    float m_orbit_vel = 4.f;

    glm::mat4x4 m_projection;
    mutable glm::mat4x4 m_vp;
    mutable bool m_dirty = true;
[/code]
Los primeros 3 miembros se usan para saber d√≥nde est√° la c√°mara, hacia d√≥nde mira (el punto en el espacio, el pivote para orbitar, no solo la direcci√≥n) y hacia d√≥nde es "arriba".

Luego est√°n los 3 modificadores de velocidad que ajust√© para las part√≠culas. Se podr√≠an exponer y modificar, pero no lo encontr√© necesario para la demo. Afectan qu√© tan r√°pido (o lento) se mueve la c√°mara en cada operaci√≥n.

Al final tenemos la matriz de proyecci√≥n (que solo cambia al cambiar la pantalla) y dos miembros <i>mutable</i>. Son as√≠ porque se usan dentro de un m√©todo <i>const</i> pero se interpretan como el cach√© de una optimizaci√≥n, los miembros importantes son los que se usan para la posici√≥n, <i>lookAt</i> y <i>up</i>.

Hice esto as√≠ porque en cada operaci√≥n es m√°s f√°cil modificar estos 3 miembros, pero calcular la matrix view-projection en cada frame, a√∫n si la c√°mara no se movi√≥ parec√≠a un desperdicio. Como cualquier cache, la variable dirty se usa para actualizarlo.
<h2>Implementaci√≥n</h2>
[code language="cpp"]
camera::camera(const glm::vec2& screen) {
    screen_change(screen);
    home();
}

void camera::screen_change(const glm::vec2& screen) {
    m_projection = glm::perspective(glm::radians(45.f), screen.x / screen.y, .5f, 100.f);

    m_dirty = true;
}

void camera::home() {
    m_pos = glm::vec3{ 0.f, 0.f, 2.7f };
    m_lookAt = glm::vec3{ 0.f, 0.f, 0.f };
    m_up = glm::vec3{ 0.f, 1.f, 0.f };
    m_dirty = true;
}
[/code]
Los 3 primeros m√©todos, nada muy importante. El constructor delega el trabajo en los otros 2.  <code>screen_change</code> recalcula la matriz proyecci√≥n como una matriz perspectiva de Pi/4 radianes de FOV vertical y .5 y 100 como los planos <i>near</i> y </far> (dando mucho espacio para dolly en la demo que est√° alrededor de (0, 0, 0)). Para est uso la implementaci√≥n del constructor de la matriz perspectiva de GLM. :)

Nota: Uso <code>glm::radians</code> porque fuerzo a GLM a trabajar en radianes. Y trabajo en radianes porque... no s√©, me acostumbre a trabajar con ellos.

Como ven, hay muchos par√°metros m√°s que se pueden exponer :)
<h3>Dolly</h3>
[code language="cpp"]
void camera::dolly(const float dz) {
    // TODO: Dolly based on hit point (not center, using mouse screenpos)
    const auto move = m_pos - m_lookAt;
    const auto curr_dist = glm::length(move);
    const auto new_dist = glm::clamp(dz * m_dolly_vel + curr_dist, 1.f, 50.f);

    m_pos = m_lookAt + (glm::normalize(move) * new_dist);
    m_dirty = true;
}
[/code]
La operaci√≥n de dolly primero calcula el actual vector <i>forward</i> inverso y el largo del mismo.

Luego calcula la nueva distancia agregando el desplazamiento escalado por el par√°metro de velocidad (la operaci√≥n de clamp asegura por lo menos 1 unidad y no m√°s de 50).

Finalmente obtiene la nueva posici√≥n de la c√°mara con el vector <i>forward</i> inverso y la nueva distancia. Como dije, dado que la operaci√≥n cambia propiedades de la c√°mara, la bandera dirty es activada.
<h3>Pan</h3>
[code language="cpp"]
void camera::pan(const glm::vec2& dd) {
    // TODO: Pan with hit point always below mouse (using mouse screenpos)
    auto adjusted_dd = dd * m_pan_vel;

    auto rev_foward = glm::normalize(m_pos - m_lookAt);
    auto right_move = glm::normalize(glm::cross(m_up, rev_foward)) * -adjusted_dd.x;
    auto up_move = m_up * adjusted_dd.y;
    auto move = up_move + right_move;
    m_pos += move;
    m_lookAt += move;
    m_dirty = true;
}
[/code]
Pan modifica ambos el pivote y la posici√≥n de la c√°mara. Haciendo una operaci√≥n similar a dolly, calcula la nueva posici√≥n moviendo la c√°mara de izquierda a derecha y de arriba hacia abajo dependiendo de los desplazamientos en x e y respectivamente.

Luego aplica el mismo desplazamiento al punto lookAt (pivote) para mantener el mismo vector <i>forward</i> y su largo.
<h3>Orbit</h3>
[code language="cpp"]
void camera::orbit(const glm::vec2& dd) {
    // TODO: Orbit with hit point always below mouse (using mouse screenpos)
    auto adjusted_dd = dd * m_orbit_vel;
    auto rev_foward = m_pos - m_lookAt;
    const auto len_rf = glm::length(rev_foward);
    rev_foward = glm::normalize(rev_foward);

    const auto h_rot = glm::rotate(glm::radians(-adjusted_dd.x), m_up);
    const auto v_rot = glm::rotate(glm::radians(-adjusted_dd.y), glm::normalize(glm::cross(m_up, rev_foward)));
    m_pos = m_lookAt + glm::vec3{ h_rot * v_rot * glm::vec4{ rev_foward, 0.f } } * len_rf;
    m_up = glm::vec3{ v_rot * glm::vec4{ m_up, 0.f } };
    m_dirty = true;
}
[/code]
Orbit es un poco m√°s complejo, pero no tanto. Piensen en 2 aros alrededor del punto de pivote, uno horizontal y uno vertical, lo que hace es calcular 2 matrices de rotaci√≥n sobre estos 2 aros usando el par√°metro de desplazamiento y el factor de velocidad.

Luego rota el vector <i>forward</i> inverso y calcula la nueva posici√≥n agreg√°ndolselo al punto de pivote. El vector <i>up</i> solo es afectado por la rotaci√≥n vertical.
<h3>Obteniendo la matriz vp</h3>
[code language="cpp"]
const glm::mat4x4& camera::get_vp() const {
    if (m_dirty) {
        m_vp = m_projection * glm::lookAt(m_pos, m_lookAt, m_up);
        m_dirty = false;
    }
    return m_vp;
}
[/code]
Como ven la matriz view-projection es calculada solo si la bandera de dirty est√° setada, si no es as√≠ simplemente se retorna. Nuevamente me ahorro trabajo al usar la funci√≥n <code>glm::lookAt</code> que genera la matriz de vista usando los vectores de posici√≥n, <i>lookAt</i> y <i>up</i>.
<h3>TODO, posici√≥n en la pantalla</h3>
Si lo notaron, todos los m√©todos arrancan con un <i>TODO</i> ("to do", "a realizar"). La cosa es que todos trabajan en una forma muy simple que era suficientemente buena para mi, y en alcunos casos es la correcta y m√°s f√°cil. Pero, es posible una modificaci√≥n a cada uno que implica mantener alguna restricci√≥n relacionada a la posici√≥n en pantalla en la cual el movimiento arranc√≥.

En el caso de dolly, esta implementaci√≥n mantiene el pixel que est√° debajo del centro de la pantalla, siempre debajo del centro de la pantalla pero, si pensamos en el punto de la pantalla donde se activo el movimiento como el origen de un rayo que va a intersectar con algo en el mundo 3D (<i>ray picking</i>), la alternativa ser√≠a darle relevancia a esta posici√≥n rotando el desplazamiento de la camara hacia este punto de intersecci√≥n.

Esto no cambiar√≠a el vector <i>forward</i>, pero el vector de desplazamiento ser√≠a calculado con el punto de intersecci√≥n y la posici√≥n de la c√°mara, en lugar del punto de pivote.

Para pan y orbit, nuestra restricci√≥n podr√≠a ser que el punto de intersecci√≥n en 3D de la posici√≥n en 2D sobre la pantalla fuese siempre el mismo durante toda la operaci√≥n (lo que sea que hay debajo del mouse o dedo siempre quedar√≠a debajo del mouse o dedo).

Estas 3 cosas son un poco m√°s complejas de realizar y no me parecieron suficientemente importantes para hacer una demo de una part√≠culas flotando sin ninguna otra referencia, as√≠ que queda como "ejercicio para el lector".

Este art√≠culo es parte de la serie <i>Particles!</i>, pueden ver entradas anteriores <a href="https://marianogonzalezn.wordpress.com/2016/04/26/particles-1/">ac√°</a>, <a href="https://marianogonzalezn.wordpress.com/2016/05/09/particles-2/">ac√°</a> and <a href="https://marianogonzalezn.wordpress.com/2016/05/16/particles-3-multithreading/">ac√°</a>. <a href="https://github.com/mariano-gn/randpart">Ac√°</a> est√° el repositorio de la demo. ¬°Espero les guste!
<a href="#es">Inicio</a>